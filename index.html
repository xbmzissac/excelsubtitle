<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智能字幕分段工具</title>
    <style>
        /* 原有样式保留，新增加载动画 */
        .loader {
            display: none;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #4a90e2;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- 容器结构保持不变 -->
    <script>
        // 配置参数
        const API_CONFIG = {
            endpoint: 'https://api.deepseek.com/v1/chat/completions',
            model: 'deepseek-chat',
            temperature: 0.2,
            max_tokens: 4096
        };

        // 处理逻辑重构
        async function processWithDeepSeek(textBlocks) {
            const batches = chunkArray(textBlocks, 5); // 分批次处理
            let allSegments = [];
            
            for (const [index, batch] of batches.entries()) {
                updateProgress((index + 1) / batches.length);
                try {
                    const response = await sendBatchRequest(batch);
                    allSegments = allSegments.concat(parseSegments(response));
                } catch (error) {
                    console.error(`Batch ${index} failed:`, error);
                    allSegments = allSegments.concat(fallbackSegmentation(batch));
                }
            }
            return allSegments;
        }

        async function sendBatchRequest(batch) {
            const response = await fetch(API_CONFIG.endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${DEEPSEEK_API_KEY}`
                },
                body: JSON.stringify({
                    model: API_CONFIG.model,
                    messages: [{
                        role: "user",
                        content: `请将以下字幕文本按语义分段，返回JSON格式（segments数组，包含text和最佳分句位置）：
示例响应：
{
  "segments": [
    {"text": "完整的第一句话", "split_position": 15},
    {"text": "接下来的第二句话", "split_position": 32}
  ]
}

需要分段的文本：
${batch.map(t => t.fullText).join('\n')}`
                    }],
                    temperature: API_CONFIG.temperature,
                    max_tokens: API_CONFIG.max_tokens
                })
            });

            if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
            return response.json();
        }

        function parseSegments(response) {
            try {
                const raw = JSON.parse(response.choices[0].message.content);
                return raw.segments.map(s => ({
                    text: s.text,
                    splitAt: s.split_position
                }));
            } catch (e) {
                throw new Error('API响应解析失败');
            }
        }

        // 时间码合并算法
        function mergeTimecodes(segments, originalBlocks) {
            let currentBlockIndex = 0;
            return segments.map(segment => {
                const timecodes = [];
                let accumulatedLength = 0;
                
                while (currentBlockIndex < originalBlocks.length) {
                    const block = originalBlocks[currentBlockIndex];
                    const remaining = segment.text.length - accumulatedLength;
                    
                    if (remaining <= 0) break;
                    
                    const takeLength = Math.min(remaining, block.text.length);
                    timecodes.push(block.timecode);
                    
                    accumulatedLength += takeLength;
                    if (takeLength === block.text.length) {
                        currentBlockIndex++;
                    } else {
                        // 处理部分匹配的情况
                        originalBlocks[currentBlockIndex].text = block.text.slice(takeLength);
                        originalBlocks[currentBlockIndex].timecode = adjustTimecode(
                            block.timecode, 
                            takeLength
                        );
                    }
                }
                
                return {
                    text: segment.text,
                    timecodes,
                    translation: findBestTranslation(segment.text, originalBlocks)
                };
            });
        }

        // 辅助函数
        function chunkArray(arr, size) {
            return Array.from({length: Math.ceil(arr.length/size)}, (_,i) => 
                arr.slice(i*size, i*size+size));
        }

        function fallbackSegmentation(batch) {
            // 基于标点的备用分段逻辑
            return batch.map(block => ({
                text: block.fullText,
                splitAt: block.fullText.length
            }));
        }
    </script>
</body>
</html>